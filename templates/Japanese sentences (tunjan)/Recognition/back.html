<div class="wrap">
  <header>
    {{#Focus}}
    <div class="tags">{{Focus}}</div>
    {{/Focus}}

    {{#Tags}}
    <div class="tags-container">
      <div class="tags">{{Tags}}</div>
    </div>
    {{/Tags}}

    <div class="jpsentence toggle-container">
      <label class="toggle-switch" title="Toggle font style (Mincho/Sans)">
        <input type="checkbox" id="fontToggle">
        <span class="slider"></span
      </label>
    </div>
  </header>

      
    <div class="sent-center">
      <div class="jpsentence" lang="ja">
        {{furigana:SentFurigana}}{{^SentFurigana}}{{furigana:SentKanji}}{{/SentFurigana}}
      </div>
      {{#SentEng}}
      <div class="ensentence" id="english-sentence" lang="en">{{hint:SentEng}}</div>
      {{/SentEng}}
    </div>


<<<<<<< HEAD
{{#VocabKanji}}
  <section class="headword_section vocab-section">
    <div class="vocab">
<div class="audio">
            <span id="vocab-audio">{{VocabAudio}}</span>
            <span id="sent-audio">{{SentAudio}}</span>
</div>
            <div class="reading" id="pitchpattern" lang="ja">
                {{VocabPitchPattern}}{{^VocabPitchPattern}}{{text:kana:VocabFurigana}}{{/VocabPitchPattern}}
            </div>
            {{#VocabPitchNum}}<span class="tags" id="pitchnum">{{text:VocabPitchNum}}</span>{{/VocabPitchNum}}
            {{#VocabKanji}}
            <div class="target_word" lang="ja">{{text:kanji:VocabKanji}}</div>
            {{/VocabKanji}}
        </div>
  </section>
  {{/VocabKanji}}
=======
>>>>>>> a841e98 (overhaul)

<section class="headword_section">

    {{#VocabKanji}}
      <div class="item vocab">
        <div class="audio" aria-label="Audio controls">
          <span id="vocab-audio">{{VocabAudio}}</span>
          <span id="sent-audio">{{SentAudio}}{{^SentAudio}}{{tts ja_JP voices=Apple_Kyoko:SentKanji}}{{/SentAudio}}</span>
        </div>
        <div class="reading jpsentence" id="pitchpattern" lang="ja">
          {{VocabPitchPattern}}{{^VocabPitchPattern}}{{text:kana:VocabFurigana}}{{/VocabPitchPattern}}
        </div>
        {{#VocabPitchNum}}<span class="tags" id="pitchnum">{{text:VocabPitchNum}}</span>{{/VocabPitchNum}}
        <div class="target_word jpsentence" lang="ja">{{text:kanji:VocabKanji}}</div>
    </div>
    {{/VocabKanji}}
	

    {{#VocabDef}}
    <div class="item">
        <h3>Definition</h3>
        <div class="definitions">{{edit:furigana:VocabDef}}</div>
    </div>
    {{/VocabDef}}


  {{#Notes}}
  <div class="item">
    <h3>Notes</h3>
    <div class="notes-content">{{furigana:Notes}}</div>
  </div>
  {{/Notes}}

</section>

  <footer>
    {{#SentKanji}}
    <a href="https://simplytranslate.org/?engine=google&text={{text:kanji:SentKanji}}&sl=ja&tl=en" title="Translate with SimplyTranslate" class="footer-link">Translate</a>
    <a href="https://jisho.org/search?keyword={{text:kanji:SentKanji}}" title="Sentence on Jisho" class="footer-link">Jisho</a>
    <a href="https://www.google.co.jp/search?q={{text:kanji:SentKanji}}&tbm=isch" title="Search images" class="footer-link">Images</a>
    {{/SentKanji}}
    {{#VocabKanji}}
    <a href="http://www.weblio.jp/content/{{text:VocabKanji}}" title="Vocab on Weblio" class="footer-link">Weblio</a>
    <a href="https://wadoku.de/search/?q={{text:VocabKanji}}" title="Vocab on Wadoku" class="footer-link">Wadoku</a>
    {{/VocabKanji}}
  </footer>

    
</div>

<div style="display: none">
    <div id="vocab_kanji_hidden">{{VocabKanji}}</div>
    <div id="pitchnum_hidden">{{VocabPitchNum}}</div>
    <div id="kanaword_hidden">{{kana:VocabFurigana}}</div>
</div>


<script>
/**
 * Anki Japanese Card Script (v25.04+ Rev C - Scrutinized & Refactored)
 *
 * NOTE: This script assumes specific HTML structure and CSS classes are present
 * in the Anki card template. Changes to the template may break this script.
 * Testability is limited due to direct DOM manipulation.
 * Certain checks (e.g., for hidden audio, pitch data presence) rely on potentially
 * brittle string matching or specific content formats generated by the template.
 * Using dedicated CSS classes or data-* attributes set by the template
 * for state (e.g., `data-audio-marked`, `data-pitch-present="false"`) is strongly recommended
 * for robustness but requires template modification.
 */
(function() {
    'use strict';

<<<<<<< HEAD
    // --- Helper Functions ---

    function isMobile() {
        // Check if the html element has the 'mobile' class (common in Anki)
        return document.documentElement.classList.contains("mobile");
    }

    /**
     * Applies a specific CSS class to target word elements for pitch accent.
     * @param {string | null} className - The CSS class name to add (e.g., 'pitch-heiban'), or null to remove all pitch classes.
     */
    function styleTargetWord(className) {
        const pitchClasses = ['pitch-heiban', 'pitch-atamadaka', 'pitch-odaka', 'pitch-nakadaka'];
        document.querySelectorAll(".jpsentence b, .jpsentence strong").forEach(word => {
            // Remove any existing pitch classes first
            word.classList.remove(...pitchClasses);
            // Add the new class if one is provided
            if (className) {
                word.classList.add(className);
            }
        });
    }

    /**
     * Determines if a word is Odaka based on pitch number and mora count.
     * Relies on hidden divs for data.
     * @param {number} pitch_num - The pitch accent number.
     * @returns {boolean} - True if the word is Odaka, false otherwise.
     */
    function is_odaka(pitch_num) {
        const kanaElement = document.getElementById("kanaword_hidden");
        const kanjiElement = document.getElementById("vocab_kanji_hidden");

        if (!kanaElement || !kanjiElement || !kanaElement.textContent || !kanjiElement.textContent) return false;

        try {
            const morasText = kanaElement.innerText.replace(/[（(＜].*[＞)）]/, "");
            const morasCount = morasText.replace(/[ャュョゃゅょァィゥェォ]/g, "").trim().length;
            const vocab_kanji = kanjiElement.innerText.trim();
            const n_moras = /な$/.test(vocab_kanji) && morasText.endsWith('な')
                ? morasCount - 1
                : morasCount;
            return n_moras === pitch_num;
        } catch (e) {
            console.error("Error in is_odaka:", e);
            return false;
        }
    }

    /**
     * Recursively formats ruby HTML for multiple readings (Anki compatibility focus).
     * @param {string} kanji - The base text (kanji).
     * @param {string[]} readings - Array of readings.
     * @returns {string} - Formatted HTML string.
     */
    function formatNewRuby(kanji, readings) {
         // Simplified structure often more compatible with Anki's rendering
        if (readings.length === 1) {
            return `<rb>${kanji}</rb><rt>${readings[0]}</rt>`;
        } else if (readings.length > 1) {
            // For multiple, try placing multiple <rt> after <rb> if nested doesn't work well
            // return `<rb>${kanji}</rb>` + readings.map(r => `<rt>${r}</rt>`).join('');
            // Or revert to potentially fragile nested version if required:
            return `<ruby>${formatNewRuby(kanji, readings.slice(0, -1))}</ruby><rt>${readings.slice(-1)}</rt>`;
        } else {
             return `<rb>${kanji}</rb>`; // Handle case with no readings?
        }
    }

    // --- Core Feature Functions ---

    /**
     * Styles the target word based on its pitch accent number from hidden div.
     */
    function markPitch() {
        const pitchElement = document.getElementById("pitchnum_hidden");
        if (!pitchElement || !pitchElement.textContent) {
             // Optionally reset style if element is missing/empty
             styleTargetWord(null);
             return;
        }

        const pitchMatch = pitchElement.textContent.match(/\d/);
        if (!pitchMatch) {
            styleTargetWord(null); // Reset color if no valid number found
            return;
        }

        const pitchNumber = Number(pitchMatch[0]);

        if (pitchNumber === 0) styleTargetWord("pitch-heiban");
        else if (pitchNumber === 1) styleTargetWord("pitch-atamadaka");
        else if (pitchNumber > 1) {
            styleTargetWord(is_odaka(pitchNumber) ? "pitch-odaka" : "pitch-nakadaka");
        }
        else styleTargetWord(null); // Reset for unexpected cases
    }

    /**
     * Splits Anki tags into separate div elements within the .tags-container.
     */
    function splitTagDiv() {
        const tagsContainer = document.querySelector("header .tags-container");
        if (!tagsContainer) return;

        const initialTagsDiv = tagsContainer.querySelector(".tags");
        let rawTagsString = "";
        if (initialTagsDiv && initialTagsDiv.textContent) {
            rawTagsString = initialTagsDiv.textContent;
        }

        // Also check for {{Focus}} tag outside the container
        const focusTagDiv = document.querySelector("header > .tags:not(.tags-container .tags)");
        const focusTag = focusTagDiv ? focusTagDiv.textContent.trim() : "";

        // Combine tags from both sources
        const allTagsString = focusTag ? `${focusTag} ${rawTagsString}` : rawTagsString;
        const individualTags = allTagsString.split(" ")
                                           .map(t => t.trim())
                                           .filter(Boolean);

        const tagsToExclude = ["imageonfront", "tolearn", "marked"];

        // Clear the container *and* remove the initial focus tag div
        tagsContainer.innerHTML = '';
        if(focusTagDiv) focusTagDiv.remove();

        let tagsAdded = false;
        individualTags.forEach(tag => {
            if (!tagsToExclude.includes(tag)) {
                const tagElem = document.createElement("div");
                tagElem.className = "tags";
                tagElem.textContent = tag;
                // Append *all* tags (including the focus one) to the container now
                tagsContainer.appendChild(tagElem);
                tagsAdded = true;
            }
        });
        // Ensure container is visible if tags were added, hide if not (optional)
        tagsContainer.style.display = tagsAdded ? '' : 'none';
    }


    /**
     * Reformats ruby elements with multiple readings, potentially adding tooltips.
     */
    function reformatMultiFurigana() {
        const separators = /[\s;,.、・。]+/iu;
        const maxInlineReadings = 1; // Show only the first reading inline

        document.querySelectorAll("ruby:not(ruby ruby)").forEach(ruby => {
            try {
                const baseTextNode = ruby.querySelector("rb") ?? ruby.firstChild;
                let kanji = baseTextNode?.textContent?.trim();
                const rtElement = ruby.querySelector("rt");

                if (!kanji || !rtElement?.textContent) return;

                 // Handle edge case where baseTextNode might include the rt content in some Anki versions
                 if (baseTextNode === ruby.firstChild && baseTextNode.nodeType === Node.TEXT_NODE && rtElement.previousSibling === baseTextNode) {
                    kanji = kanji.replace(rtElement.textContent, '').trim();
                 }

                const readings = rtElement.textContent.split(separators)
                    .map(str => str.trim())
                    .filter(str => str.length > 0);

                if (readings.length > maxInlineReadings) {
                    const inlineRuby = document.createElement('ruby');
                    inlineRuby.innerHTML = formatNewRuby(kanji, readings.slice(0, maxInlineReadings)); // Use helper

                    const tooltipTextSpan = document.createElement("span");
                    tooltipTextSpan.className = "tooltip-text";
                    tooltipTextSpan.innerHTML = readings
                        .map(reading => `<span class="tooltip-reading">${reading}</span>`)
                        .join("");

                    const tooltipWrapper = document.createElement("span");
                    tooltipWrapper.className = "tooltip";
                    tooltipWrapper.appendChild(inlineRuby);
                    tooltipWrapper.appendChild(tooltipTextSpan);

                    ruby.replaceWith(tooltipWrapper);
                }
            } catch (error) {
                console.error("Error processing ruby element:", ruby, error);
            }
        });
    }

    /**
     * Shows elements with class .images-on-front if 'imageonfront' tag is present.
     */
    function setVisibleImageOnFront() {
        // This relies on {{Tags}} being accessible, which might only be reliable
        // if the hidden data divs are added OR if this runs on the Front template.
        // A safer approach might involve checking the container directly if {{Tags}} isn't available.
        try {
             const tags = `{{Tags}}`; // Anki field replacement placeholder
             if (tags.split(" ").includes("imageonfront")) {
                 document.querySelectorAll(".images-on-front").forEach(imgContainer => {
                     imgContainer.setAttribute("visible", "true");
                 });
             }
        } catch(e) {
            console.warn("Could not check {{Tags}} for image visibility. Field might be missing.");
        }
    }

    /**
     * Sets the 'open' attribute on image details sections based on mobile status.
     */
    function toggleImageDetails() {
        const shouldBeOpen = !isMobile();
        document.querySelectorAll(".images-details").forEach(detailsElement => {
            detailsElement.open = shouldBeOpen; // Directly set the boolean property
        });
    }

    /**
     * Toggles the inline visibility style of furigana within JP1K mode elements.
     */
    function toggleJP1KFurigana() {
        document.querySelectorAll(".jp1k-mode ruby rt").forEach(rtElement => {
            rtElement.style.visibility = rtElement.style.visibility === 'visible' ? '' : 'visible';
        });
    }

    /**
     * Sets the visibility attribute of TSC vs JP1K mode containers based on the 'jp1k' tag.
     */
    function toggleJP1KModeVisibility() {
        const tscElement = document.querySelector(".tsc");
        const jp1kElement = document.querySelector(".jp1k-mode");
        if (!tscElement || !jp1kElement) return; // Need both elements

        // Similar issue to setVisibleImageOnFront - relies on {{Tags}}.
        try {
            const tags = `{{Tags}}`; // Anki field replacement placeholder
            const isJP1KMode = tags.toLowerCase().split(" ").includes("jp1k");

            jp1kElement.setAttribute("visible", isJP1KMode ? "true" : "false");
            tscElement.setAttribute("visible", !isJP1KMode ? "true" : "false");
        } catch(e) {
            console.warn("Could not check {{Tags}} for JP1K mode visibility. Field might be missing.");
            // Default to showing TSC mode if tags check fails?
             jp1kElement.setAttribute("visible", "false");
             tscElement.setAttribute("visible", "true");
        }
    }

    // --- Back Card Specific Cleanup ---

    function tweakRevealText() {
        const elem = document.querySelector("div.ensentence > a.hint");
        if (elem) {
            elem.innerText = "Reveal English translation";
        }
    }

    function removePitchBrackets() {
        const pitchElement = document.getElementById("pitchnum"); // Element displayed on back
        if (pitchElement) {
            pitchElement.innerHTML = pitchElement.innerHTML.replace(/[\[\]]/g, "");
        }
    }

    function removeNoPitchAccentDataText() {
        const hasNoData = (element) => element && element.textContent.toLowerCase().includes("no pitch accent");

        const pitchNumElement = document.getElementById("pitchnum"); // Displayed on back
        const pitchPatternElement = document.getElementById("pitchpattern"); // Displayed on back
        // Note: .pitch_number class might not exist/be relevant on the back depending on CSS/HTML
        const pitchNumInlineSpan = pitchPatternElement?.querySelector(".ajt__pitch_number_tag"); // More specific?

        if (hasNoData(pitchNumElement)) {
            pitchNumElement.remove();
        }
        if (hasNoData(pitchNumInlineSpan)) {
             pitchNumInlineSpan.remove();
        }

        if (hasNoData(pitchPatternElement)) {
            const kanaWordElement = document.getElementById("kanaword_hidden");
            pitchPatternElement.textContent = kanaWordElement ? kanaWordElement.textContent : '';
        }
    }

    function removeAudioIfMarkedX() {
        const audioContainer = document.getElementById("vocab-audio");
        if (audioContainer && audioContainer.textContent.trim().match(/^[x×]/i)) {
            audioContainer.style.display = "none";
        }
         // Also check SentAudio if it exists
         const sentAudioContainer = document.getElementById("sent-audio");
          if (sentAudioContainer && sentAudioContainer.textContent.trim().match(/^[x×]/i)) {
            sentAudioContainer.style.display = "none";
        }
    }

    // --- Event Listener Setup ---

    /**
     * Sets up the font toggle checkbox functionality using CSS classes.
     */
    function setupFontToggle() {
        const fontToggle = document.getElementById('fontToggle');
        if (!fontToggle) return;

        const jpSentences = document.querySelectorAll('.jpsentence');
        if (jpSentences.length === 0) return;

        const applyFontPreference = (isChecked) => {
            const classToAdd = isChecked ? 'font-mincho' : 'font-sans';
            const classToRemove = isChecked ? 'font-sans' : 'font-mincho';
            jpSentences.forEach(element => {
                element.classList.remove(classToRemove);
                element.classList.add(classToAdd);
            });
            try {
                localStorage.setItem('fontPreference', isChecked ? 'mincho' : 'sans');
            } catch (e) { /* Ignore */ }
        };

        fontToggle.addEventListener('change', function() {
            applyFontPreference(this.checked);
        });

        // Initialize state
        try {
            let initialCheckedState = (localStorage.getItem('fontPreference') === 'mincho');
            fontToggle.checked = initialCheckedState;
            applyFontPreference(initialCheckedState);
        } catch (e) {
            fontToggle.checked = false; // Default to false on error
            applyFontPreference(false);
        }
    }

    /**
     * Sets up keyboard listeners for 'P' (toggle furigana) and 'A' (reveal hints).
     */
    function setupKeyListeners() {
        // Only add listeners if we are likely on the front card (where interaction happens)
        if (document.querySelector(".tsc") || document.querySelector(".jp1k-mode")) {
            document.addEventListener("keydown", (event) => {
                const key = event.key?.toUpperCase() || event.code;
                if (key === "P" || key === "KEYP") {
                    toggleJP1KFurigana();
                } else if (key === "A" || key === "KEYA") {
                    document.querySelectorAll("a.hint").forEach(elem => elem.click());
                }
            }, true);
        }
    }

    /**
     * Sets up the click listener for the JP1K furigana toggle button.
     */
    function setupJP1KButtonListener() {
        const toggleButton = document.querySelector(".jp1k-mode .toggle_furigana_button");
        if (toggleButton) {
            toggleButton.addEventListener('click', toggleJP1KFurigana);
        }
    }


    // --- Initialization ---

    /**
     * Main initialization function, calls appropriate functions based on context.
     */
    function initialize() {
        console.log("Card script initializing...");

        // --- Functions needed on BOTH Front and Back ---
        setupFontToggle(); // Reads/sets preference, needed always
        splitTagDiv();     // Process tags display if container exists
        reformatMultiFurigana(); // Process ruby if it exists
        toggleImageDetails();    // Set initial image details state (open/closed)

        // --- Front-only Functions (Check for elements unique to Front) ---
        const isFront = document.querySelector(".tsc") || document.querySelector(".jp1k-mode");
        if (isFront) {
             console.log("Running Front-specific setup...");
             setupKeyListeners();
             setupJP1KButtonListener();
             setVisibleImageOnFront(); // Checks {{Tags}} placeholder
             toggleJP1KModeVisibility(); // Checks {{Tags}} placeholder
        }

        // --- Back-only Functions (Check for elements unique to Back) ---
        const isBack = document.querySelector(".definitions") || document.querySelector(".notes-content") || document.getElementById("pitchnum");
        if (isBack) {
            console.log("Running Back-specific setup...");
             // Requires hidden divs on Back template!
            if (document.getElementById('pitchnum_hidden')) {
                 markPitch();
            } else {
                 console.warn("Cannot mark pitch: #pitchnum_hidden not found on Back.");
            }
            tweakRevealText();
            removePitchBrackets();
            removeNoPitchAccentDataText();
            removeAudioIfMarkedX();
        }
         console.log("Card script initialization complete.");
    }

    // Wait for the DOM to be ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        // DOM is already ready
        initialize();
    }

})();
</script>


<script>
/* AJT Japanese JS 25.4.5.1 */
/* DO NOT EDIT! This code will be overwritten by AJT Japanese. */
function ajt__kana_to_moras(text) { return text.match(/.[°゚]?[ァィゥェォャュョぁぃぅぇぉゃゅょ]?/gu); } function ajt__norm_handakuten(text) { return text.replace(/\u{b0}/gu, "\u{309a}"); } function ajt__make_pattern(kana, pitch_type, pitch_num) { const moras = ajt__kana_to_moras(ajt__norm_handakuten(kana)); switch (pitch_type) { case "atamadaka": return ( `<span class="ajt__HL">${moras[0]}</span>` + `<span class="ajt__L">${moras.slice(1).join("")}</span>` + `<span class="ajt__pitch_number_tag">1</span>` ); break; case "heiban": return ( `<span class="ajt__LH">${moras[0]}</span>` + `<span class="ajt__H">${moras.slice(1).join("")}</span>` + `<span class="ajt__pitch_number_tag">0</span>` ); break; case "odaka": return ( `<span class="ajt__LH">${moras[0]}</span>` + `<span class="ajt__HL">${moras.slice(1).join("")}</span>` + `<span class="ajt__pitch_number_tag">${moras.length}</span>` ); break; case "nakadaka": return ( `<span class="ajt__LH">${moras[0]}</span>` + `<span class="ajt__HL">${moras.slice(1, Number(pitch_num)).join("")}</span>` + `<span class="ajt__L">${moras.slice(Number(pitch_num)).join("")}</span>` + `<span class="ajt__pitch_number_tag">${pitch_num}</span>` ); break; } } function ajt__format_new_ruby(kanji, readings) { if (readings.length > 1) { return `<ruby>${ajt__format_new_ruby(kanji, readings.slice(0, -1))}</ruby><rt>${readings.slice(-1)}</rt>`; } else { return `${kanji}<rt>${readings.join("")}</rt>`; } } function ajt__zip(array1, array2) { let zipped = []; const size = Math.min(array1.length, array2.length); for (let i = 0; i < size; i++) { zipped.push([array1[i], array2[i]]); } return zipped; } function ajt__make_accent_list_item(kana_reading, pitch_accent) { const list_item = document.createElement("li"); for (const [reading_part, pitch_part] of ajt__zip(kana_reading.split("・"), pitch_accent.split(","))) { const [pitch_type, pitch_num] = pitch_part.split("-"); const pattern = ajt__make_pattern(reading_part, pitch_type, pitch_num); list_item.insertAdjacentHTML("beforeend", `<span class="ajt__downstep_${pitch_type}">${pattern}</span>`); } return list_item; } function ajt__make_accents_list(ajt_span) { const accents = document.createElement("ul"); for (const accent_group of ajt_span.getAttribute("pitch").split(" ")) { accents.appendChild(ajt__make_accent_list_item(...accent_group.split(":"))); } return accents; } function ajt__make_popup_div(content) { const frame_top = document.createElement("div"); frame_top.classList.add("ajt__frame_title"); frame_top.innerText = "Information"; const frame_bottom = document.createElement("div"); frame_bottom.classList.add("ajt__frame_content"); frame_bottom.appendChild(content); const popup = document.createElement("div"); popup.classList.add("ajt__info_popup"); popup.appendChild(frame_top); popup.appendChild(frame_bottom); return popup; } function ajt__find_word_info_popup(word_span) { return word_span.querySelector(".ajt__info_popup"); } function ajt__find_popup_x_corners(popup_div) { const elem_rect = popup_div.getBoundingClientRect(); const right_corner_x = elem_rect.x + elem_rect.width; return { x_start: elem_rect.x, x_end: right_corner_x, shifted_x_start: elem_rect.x + elem_rect.width / 2, shifted_x_end: right_corner_x + elem_rect.width / 2, }; } function ajt__word_info_on_mouse_enter(word_span) { const popup_div = ajt__find_word_info_popup(word_span); if (popup_div) { ajt__word_info_on_mouse_leave(word_span); const x_pos = ajt__find_popup_x_corners(popup_div); if (x_pos.x_start < 0) { popup_div.classList.add("ajt__left-corner"); popup_div.style.setProperty("--shift-x", `${Math.ceil(-x_pos.x_start)}px`); } else if (x_pos.shifted_x_end < window.innerWidth) { popup_div.classList.add("ajt__in-middle"); } } } function ajt__word_info_on_mouse_leave(word_span) { const popup_div = ajt__find_word_info_popup(word_span); if (popup_div) { popup_div.classList.remove("ajt__left-corner", "ajt__in-middle"); } } function ajt__adjust_popup_position_on_mouse_enter(word_info_span) { word_info_span.addEventListener("mouseenter", (event) => ajt__word_info_on_mouse_enter(event.currentTarget)); word_info_span.addEventListener("mouseleave", (event) => ajt__word_info_on_mouse_leave(event.currentTarget)); } function ajt__format_readings_as_list(readings) { const readings_items = readings.map((reading) => `<li>${reading}</li>`).join(""); const list_elem = document.createElement("ol"); list_elem.classList.add("ajt__readings_list"); list_elem.insertAdjacentHTML("beforeend", readings_items); return list_elem; } function ajt__fixup_br(element) { element.querySelectorAll("br").forEach((element) => { element.insertAdjacentText("afterend", " "); element.remove(); }); return element; } function ajt__find_kanji_readings(ruby_tag) { const separators = /[\n\s;,.、・。]+/iu; const kanji = (ruby_tag.querySelector("rb") || ruby_tag.firstChild).textContent.trim(); const readings = ajt__fixup_br(ruby_tag.querySelector("rt")) .textContent.split(separators) .map((str) => str.trim()) .filter((str) => str.length); return { kanji: kanji, readings: readings }; } function ajt__reformat_multi_furigana() { const max_inline = 2; document.querySelectorAll("ruby:not(ruby ruby):not(.ajt__furigana_list ruby)").forEach((ruby) => { try { const { kanji, readings } = ajt__find_kanji_readings(ruby); if (readings.length > 1) { ruby.innerHTML = ajt__format_new_ruby(kanji, readings.slice(0, max_inline)); } if (readings.length > max_inline && !ruby.matches(".ajt__word_info ruby")) { const content_ul = ajt__format_readings_as_list(readings); const popup = ajt__make_popup_div(content_ul); const wrapper = document.createElement("span"); ruby.replaceWith(wrapper); wrapper.appendChild(ruby); wrapper.appendChild(popup); wrapper.classList.add("ajt__furigana_list"); ajt__adjust_popup_position_on_mouse_enter(wrapper); } } catch (error) { console.error(error); } }); } function ajt__create_popups() { for (const [idx, span] of document.querySelectorAll(".ajt__word_info").entries()) { if (span.matches(".jpsentence .background *")) { continue; } if (ajt__find_word_info_popup(span)) { continue; } try { const content_ul = ajt__make_accents_list(span); const popup = ajt__make_popup_div(content_ul); popup.setAttribute("ajt__popup_idx", idx); span.setAttribute("ajt__popup_idx", idx); span.appendChild(popup); ajt__adjust_popup_position_on_mouse_enter(span); } catch (error) { console.error(error); } } } function ajt__main() { ajt__create_popups(); ajt__reformat_multi_furigana(); } if (document.readyState === "loading") { document.addEventListener("DOMContentLoaded", ajt__main); } else { ajt__main(); }
</script>
=======
    // --- Configuration ---
    // Flattened structure, UPPER_SNAKE_CASE for constants.
    const CONFIG = {
        // Pitch Accent
        PITCH_CLASSES: ['pitch-heiban', 'pitch-atamadaka', 'pitch-odaka', 'pitch-nakadaka'],

        // Tags
        TAGS_TO_EXCLUDE: ["tolearn", "marked"],
        JP1K_TAG: "jp1k",

        // Furigana / Tooltips
        MAX_INLINE_READINGS: 1,

        // Keyboard Shortcuts (Front Card Only)
        KEY_TOGGLE_FURIGANA: 'p',
        KEY_REVEAL_HINTS: 'a',

        // Local Storage Keys
        STORAGE_KEY_FONT_PREF: 'ankiJpFontPreference',
        STORAGE_VALUE_FONT_MINCHO: 'mincho',
        STORAGE_VALUE_FONT_SANS: 'sans',

        // CSS Classes (Ensure these exist in your CSS)
        CSS_FONT_MINCHO: 'font-mincho',
        CSS_FONT_SANS: 'font-sans',
        CSS_HIDDEN: 'hidden', // General purpose hidden class (e.g., display: none !important;)
        CSS_VISIBLE: 'visible', // General purpose visible class (e.g., display: block/inline...;)
        CSS_TOOLTIP: 'tooltip',
        CSS_TOOLTIP_TEXT: 'tooltip-text',
        CSS_TOOLTIP_READING: 'tooltip-reading',
        CSS_FURIGANA_RT_VISIBLE: 'furigana-rt-visible', // For toggling JP1K furigana visibility
        CSS_AUDIO_HIDDEN: 'audio-hidden', // Class to hide marked audio elements
        CSS_TAG_ELEMENT: 'tags', // Class for individual tag divs

        // Selectors
        // Avoid overly complex nested selectors where possible.
        SELECTOR_TARGET_WORD: ".jpsentence b, .jpsentence strong",
        SELECTOR_FRONT_CARD_CONTAINER: ".tsc, .jp1k-mode", // Generic front card check
        SELECTOR_JP1K_MODE_CONTAINER: ".jp1k-mode",
        SELECTOR_TSC_MODE_CONTAINER: ".tsc",
        SELECTOR_JP1K_TOGGLE_BUTTON: ".jp1k-mode .toggle_furigana_button",
        SELECTOR_JP1K_RUBY_RT: ".jp1k-mode ruby rt", // JP1K specific rt for toggling

        SELECTOR_BACK_CARD_CONTAINER: ".definitions, .notes-content, #pitchnum", // Generic back card check
        SELECTOR_VOCAB_AUDIO: "#vocab-audio",
        SELECTOR_SENT_AUDIO: "#sent-audio",
        SELECTOR_HINT_LINK: "div.ensentence > a.hint",
        SELECTOR_PITCH_NUM_DISPLAY: "#pitchnum",
        SELECTOR_PITCH_PATTERN_DISPLAY: "#pitchpattern",

        SELECTOR_TAGS_CONTAINER: "header .tags-container",
        SELECTOR_FOCUS_TAG: "header > .tags:not(.tags-container .tags)", // Focus tag (outside container)
        SELECTOR_ALL_TAGS_IN_CONTAINER: "header .tags-container .tags", // Tags inside container
        SELECTOR_FONT_TOGGLE: '#fontToggle',
        SELECTOR_JP_SENTENCE: '.jpsentence',
        SELECTOR_RUBY_TOP_LEVEL: "ruby:not(ruby ruby)",

        SELECTOR_HIDDEN_PITCH_NUM: "#pitchnum_hidden",
        SELECTOR_HIDDEN_KANA_WORD: "#kanaword_hidden",
        SELECTOR_HIDDEN_VOCAB_KANJI: "#vocab_kanji_hidden",

        SELECTOR_PITCH_PATTERN_NUMBER_TAG: ".ajt__pitch_number_tag", // Within pitch pattern SVG/HTML

        // Logging & Errors
        LOG_PREFIX: "AnkiJP:",
        ERROR_LOCAL_STORAGE_READ: "Failed to read from localStorage.",
        ERROR_LOCAL_STORAGE_WRITE: "Failed to write to localStorage.",
        ERROR_CALLBACK: "Error executing callback for selector",
        ERROR_DOM_ACCESS: "DOM element not found or inaccessible for selector",
        ERROR_PITCH_CALC: "Error calculating pitch accent.",
        ERROR_RUBY_PROCESSING: "Error processing ruby element.",
        ERROR_INITIALIZATION: "Critical error during card initialization."
    };

    // --- Core Utility Services ---

    const Logger = {
        log(...args) { console.log(CONFIG.LOG_PREFIX, ...args); },
        warn(...args) { console.warn(CONFIG.LOG_PREFIX, ...args); },
        error(...args) { console.error(CONFIG.LOG_PREFIX, ...args); }
        // Note: Production logging might need levels, redirection etc.
    };

    const Storage = {
        get(key, defaultValue = null) {
            try {
                const value = localStorage.getItem(key);
                return value !== null && value !== undefined ? value : defaultValue;
            } catch (e) {
                Logger.warn(CONFIG.ERROR_LOCAL_STORAGE_READ, key, e); // Log full error
                return defaultValue;
            }
        },
        set(key, value) {
            try {
                localStorage.setItem(key, value);
                return true;
            } catch (e) {
                Logger.warn(CONFIG.ERROR_LOCAL_STORAGE_WRITE, key, e); // Log full error
                return false;
                // Consider if critical storage failures should throw
                // throw new Error(`${CONFIG.ERROR_LOCAL_STORAGE_WRITE} Key: ${key}`);
            }
        }
    };

    const DOM = {
        // Note: These assume selectors in CONFIG are valid CSS selectors.
        // Invalid selectors will throw errors upstream.
        get(selector) { return document.querySelector(selector); },
        getAll(selector) { return document.querySelectorAll(selector); },

        getText(selector) {
            const element = this.get(selector);
            return element ? element.textContent.trim() : '';
        },
        setText(element, text) {
            if (element) { element.textContent = text; }
        },
        create(tagName, options = {}) {
            const element = document.createElement(tagName);
            if (options.className) element.className = options.className;
            if (options.textContent) this.setText(element, options.textContent);
            if (options.attributes) {
                Object.entries(options.attributes).forEach(([key, value]) => {
                    element.setAttribute(key, value);
                });
            }
            return element;
        },
        addClass(element, className) {
            if (element) element.classList.add(className);
        },
        removeClass(element, className) {
            if (element) element.classList.remove(className);
        },
        toggleClass(element, className, force) {
            if (element) element.classList.toggle(className, force);
        },
        setAttributes(element, attributes) {
             if (element && attributes) {
                 Object.entries(attributes).forEach(([key, value]) => {
                     element.setAttribute(key, value);
                 });
             }
        },
        // Executes callback if element exists, re-throws callback errors.
        withElement(selector, callback) {
            const element = this.get(selector);
            if (element && typeof callback === 'function') {
                try {
                    callback(element);
                } catch (e) {
                    Logger.error(CONFIG.ERROR_CALLBACK, selector, e);
                    throw e; // Re-throw to signal failure upwards
                }
            }
            return element;
        },
        // Executes callback for each element, logs errors but continues, re-throws first error after loop.
        withElements(selector, callback) {
            const elements = this.getAll(selector);
            let firstError = null;
            if (elements.length > 0 && typeof callback === 'function') {
                elements.forEach(element => {
                    try {
                        callback(element);
                    } catch (e) {
                        Logger.error(CONFIG.ERROR_CALLBACK, selector, "(within loop)", e);
                        if (!firstError) firstError = e; // Capture first error
                    }
                });
            }
            if (firstError) throw firstError; // Re-throw the first encountered error
            return elements;
        },
        // Uses CSS classes for visibility (requires CONFIG.CSS_HIDDEN / CSS_VISIBLE in CSS)
        setVisibility(selector, isVisible) {
            this.withElements(selector, element => {
                 this.toggleClass(element, CONFIG.CSS_HIDDEN, !isVisible);
                 // Optionally add a 'visible' class if needed for specific styling overrides
                 // this.toggleClass(element, CONFIG.CSS_VISIBLE, isVisible);
            });
        },
        clearChildren(element) {
            if (element) { element.replaceChildren(); }
        },
        removeElement(element) {
             if (element && element.parentNode) {
                 element.parentNode.removeChild(element);
             }
        }
    };

    const Env = {
        // Evaluate dynamically, avoid potentially stale cache.
        isMobile() { return document.documentElement.classList.contains("mobile"); },
        isFrontCard() { return !!DOM.get(CONFIG.SELECTOR_FRONT_CARD_CONTAINER); },
        isBackCard() { return !!DOM.get(CONFIG.SELECTOR_BACK_CARD_CONTAINER); },
        // Checks if field exists AND has non-empty trimmed content
        hasField(selector) {
            const element = DOM.get(selector);
            // Ensure element exists and its textContent is not just whitespace
            return !!element && element.textContent.trim() !== '';
        }
    };

    // --- Feature-Specific Services ---

    const TagService = {
        _cachedTags: null,

        getAll() {
            if (this._cachedTags !== null) return this._cachedTags;

            const focusTagText = DOM.getText(CONFIG.SELECTOR_FOCUS_TAG);
            const containerTagsText = DOM.getText(CONFIG.SELECTOR_ALL_TAGS_IN_CONTAINER); // Corrected selector usage
            const combinedTags = `${focusTagText} ${containerTagsText}`.trim();

            this._cachedTags = combinedTags
                .split(/\s+/) // Split on whitespace
                .map(tag => tag.trim().toLowerCase())
                .filter(Boolean); // Remove empty strings

            return this._cachedTags;
        },

        has(tagName) {
            return this.getAll().includes(tagName.toLowerCase());
        },

        process() {
            // Dependency: Called before UI changes based on tags (e.g., JP1K mode)
            const tagsContainer = DOM.get(CONFIG.SELECTOR_TAGS_CONTAINER);
            if (!tagsContainer) return;

            const allTags = this.getAll();

            // Remove original focus tag element if it exists and is separate
            DOM.withElement(CONFIG.SELECTOR_FOCUS_TAG, DOM.removeElement);
            // Clear existing tags *within* the container if they were structured differently before
            DOM.withElements(CONFIG.SELECTOR_ALL_TAGS_IN_CONTAINER, DOM.removeElement);
            // Or simply clear the whole container if it only holds tags:
            // DOM.clearChildren(tagsContainer);


            let tagsAdded = false;
            const fragment = document.createDocumentFragment();

            allTags.forEach(tag => {
                if (!CONFIG.TAGS_TO_EXCLUDE.includes(tag)) {
                    const tagElem = DOM.create('div', {
                        className: CONFIG.CSS_TAG_ELEMENT, // Use class name constant
                        textContent: tag
                    });
                    fragment.appendChild(tagElem);
                    tagsAdded = true;
                }
            });

            if (tagsAdded) {
                tagsContainer.appendChild(fragment);
                DOM.removeClass(tagsContainer, CONFIG.CSS_HIDDEN); // Make visible using class
            } else {
                DOM.addClass(tagsContainer, CONFIG.CSS_HIDDEN); // Hide using class
            }
        }
    };

    const PitchService = {
        // Use fixed cache property names
        _pitchNumElementCache: null,
        _kanaWordElementCache: null,
        _vocabKanjiElementCache: null,

        _getHiddenElement(selectorKey) { // Pass key string e.g., 'pitchNum'
            const cacheProp = `_${selectorKey}ElementCache`;
            const selector = CONFIG[`SELECTOR_HIDDEN_${selectorKey.toUpperCase()}`];
            if (!this[cacheProp]) {
                 this[cacheProp] = DOM.get(selector);
            }
            return this[cacheProp];
        },
        _getHiddenText(selectorKey) {
            const element = this._getHiddenElement(selectorKey);
            return element ? element.textContent.trim() : '';
        },

        getAccentNumber() {
            const pitchText = this._getHiddenText('pitchNum');
            if (!pitchText) return null;
            // Use parseInt for number extraction, handle non-numeric results
            const pitchNum = parseInt(pitchText.replace(/[\[\]]/g, ""), 10); // Remove brackets first
            return isNaN(pitchNum) ? null : pitchNum;
        },

        _calculateMoras(text) {
            if (!text) return 0;
            // WARNING: This mora calculation is basic and may fail on edge cases.
            // Consider a dedicated library for robust Japanese text processing if accuracy is critical.
            const morasText = text.replace(/[（(＜].*[＞)）]/, ""); // Remove simple parentheticals
            return morasText.replace(/[ャュョゃゅょァィゥェォ]/g, "").length; // Remove small kana/lengthening
        },

        // Refactored slightly for clarity
        _isOdaka(pitchNum, kanaText, vocabKanji) {
            // Guard clauses
            if (pitchNum === null || pitchNum <= 0 || !kanaText) return false;

            try {
                const morasCount = this._calculateMoras(kanaText);
                if (morasCount === 0) return false; // Cannot be odaka if no moras

                // Adjust count for な-adjectives ending in な
                const isNaAdjEndingNa = /な$/.test(vocabKanji) && kanaText.endsWith('な');
                const adjustedCount = isNaAdjEndingNa ? morasCount - 1 : morasCount;

                // Ensure adjusted count is positive before comparison
                return adjustedCount > 0 && adjustedCount === pitchNum;

            } catch (e) {
                Logger.error(CONFIG.ERROR_PITCH_CALC, "(isOdaka)", e);
                return false;
            }
        },

        getAccentClass(pitchNum) {
            if (pitchNum === null) return null;
            if (pitchNum === 0) return CONFIG.PITCH_CLASSES[0]; // Heiban
            if (pitchNum === 1) return CONFIG.PITCH_CLASSES[1]; // Atamadaka

            if (pitchNum > 1) {
                // Fetch dependencies needed for odaka check
                const kanaWord = this._getHiddenText('kanaWord');
                const vocabKanji = this._getHiddenText('vocabKanji');
                return this._isOdaka(pitchNum, kanaWord, vocabKanji)
                       ? CONFIG.PITCH_CLASSES[2] // Odaka
                       : CONFIG.PITCH_CLASSES[3]; // Nakadaka
            }
            return null; // Should not be reached
        },

        styleTargetWord(className) {
            DOM.withElements(CONFIG.SELECTOR_TARGET_WORD, word => {
                // More targeted class manipulation
                let classRemoved = false;
                CONFIG.PITCH_CLASSES.forEach(cls => {
                    if (word.classList.contains(cls)) {
                        DOM.removeClass(word, cls);
                        classRemoved = true;
                    }
                });
                // Add the new class if provided
                if (className) {
                    DOM.addClass(word, className);
                }
                // Alternatively, using classList.replace (might be simpler if always replacing)
                // const currentClass = CONFIG.PITCH_CLASSES.find(cls => word.classList.contains(cls));
                // if (currentClass && className && currentClass !== className) {
                //     word.classList.replace(currentClass, className);
                // } else if (currentClass && !className) {
                //     DOM.removeClass(word, currentClass);
                // } else if (!currentClass && className) {
                //     DOM.addClass(word, className);
                // }
            });
        },

        mark() {
            const pitchNum = this.getAccentNumber();
            const accentClass = this.getAccentClass(pitchNum); // Handles null pitchNum
            this.styleTargetWord(accentClass); // Handles null accentClass
        },

        cleanDisplay() {
            // Remove brackets from pitch number display
            DOM.withElement(CONFIG.SELECTOR_PITCH_NUM_DISPLAY, elem => {
                DOM.setText(elem, elem.textContent.replace(/[\[\]]/g, ""));
            });

            // WARNING: The following relies on specific text "no pitch accent".
            // Using data attributes or classes set by the template is more robust.
            const hasNoDataText = (el) => el && el.textContent.toLowerCase().includes("no pitch accent");

            const pitchNumElem = DOM.get(CONFIG.SELECTOR_PITCH_NUM_DISPLAY);
            if (hasNoDataText(pitchNumElem)) DOM.removeElement(pitchNumElem);

            DOM.withElement(CONFIG.SELECTOR_PITCH_PATTERN_DISPLAY, pitchPatternElem => {
                 const pitchNumSpan = pitchPatternElem.querySelector(CONFIG.SELECTOR_PITCH_PATTERN_NUMBER_TAG);
                 if (hasNoDataText(pitchNumSpan)) DOM.removeElement(pitchNumSpan);

                 if (hasNoDataText(pitchPatternElem)) {
                     const kanaWord = this._getHiddenText('kanaWord');
                     if (kanaWord) {
                          DOM.setText(pitchPatternElem, kanaWord);
                     } else {
                          DOM.removeElement(pitchPatternElem);
                     }
                 }
            });
        }
    };

    const FuriganaService = {
        _createRubyContent(kanji, readings) {
            const fragment = document.createDocumentFragment();
            fragment.appendChild(DOM.create('rb', { textContent: kanji }));
            readings.forEach(reading => {
                fragment.appendChild(DOM.create('rt', { textContent: reading }));
            });
            return fragment;
        },
        _createTooltip(kanji, allReadings) {
            const inlineReadings = allReadings.slice(0, CONFIG.MAX_INLINE_READINGS);
            const tooltipReadings = allReadings.slice(CONFIG.MAX_INLINE_READINGS);

            const inlineRuby = DOM.create('ruby');
            inlineRuby.appendChild(this._createRubyContent(kanji, inlineReadings));

            const tooltipText = DOM.create('span', { className: CONFIG.CSS_TOOLTIP_TEXT });
            tooltipReadings.forEach(reading => {
                tooltipText.appendChild(DOM.create('span', {
                    className: CONFIG.CSS_TOOLTIP_READING,
                    textContent: reading
                }));
            });

            const tooltip = DOM.create('span', { className: CONFIG.CSS_TOOLTIP });
            tooltip.appendChild(inlineRuby);
            tooltip.appendChild(tooltipText);
            return tooltip;
        },

        processMultipleReadings() {
            DOM.withElements(CONFIG.SELECTOR_RUBY_TOP_LEVEL, ruby => {
                // Inner try...catch for resilience against single element failure
                try {
                    const rbElement = ruby.querySelector("rb");
                    const rtElement = ruby.querySelector("rt");
                    if (!rbElement || !rtElement || !rtElement.textContent) return;

                    const kanji = rbElement.textContent.trim();
                    const readingsRaw = rtElement.textContent.trim();
                    if (!kanji || !readingsRaw) return;

                    // Robust splitting (adjust regex if format differs)
                    const readings = readingsRaw
                        .split(/[\s;,.、・。]+/u) // Split on various separators
                        .map(str => str.trim())
                        .filter(Boolean); // Remove empty strings

                    if (readings.length > CONFIG.MAX_INLINE_READINGS) {
                        const tooltipElement = this._createTooltip(kanji, readings);
                        ruby.replaceWith(tooltipElement);
                    } else if (readings.length > 0 && readings.length <= CONFIG.MAX_INLINE_READINGS) {
                        // Ensure correct structure even if <= MAX_INLINE_READINGS
                        // Rebuild safely if necessary (e.g., original rt had multiple spaced readings)
                        const simpleRuby = DOM.create('ruby');
                        simpleRuby.appendChild(this._createRubyContent(kanji, readings));
                        ruby.replaceWith(simpleRuby);
                    }
                    // Else: 0 readings found after split/filter, leave original structure? Or remove rt?
                    // Current logic leaves original structure if readings array is empty.

                } catch (error) {
                    Logger.error(CONFIG.ERROR_RUBY_PROCESSING, error, ruby);
                    // Continue with the next ruby element
                }
            });
        },

        // Toggle visibility using CSS class
        toggleJP1KVisibility() {
            // Only affects specific rt elements in JP1K mode
            DOM.withElements(CONFIG.SELECTOR_JP1K_RUBY_RT, rt => {
                // Check current visibility based on class presence *or* computed style if needed
                // For simplicity, assume class toggling is sufficient
                DOM.toggleClass(rt, CONFIG.CSS_FURIGANA_RT_VISIBLE);
            });
        }
    };

    const FontService = {
        _applyFontClasses(isMincho) {
            const classToAdd = isMincho ? CONFIG.CSS_FONT_MINCHO : CONFIG.CSS_FONT_SANS;
            const classToRemove = isMincho ? CONFIG.CSS_FONT_SANS : CONFIG.CSS_FONT_MINCHO;

            // Apply to all relevant elements efficiently
            DOM.withElements(CONFIG.SELECTOR_JP_SENTENCE, elem => {
                // Use classList methods for efficiency
                if (elem.classList.contains(classToRemove)) {
                    elem.classList.remove(classToRemove);
                }
                if (!elem.classList.contains(classToAdd)) {
                    elem.classList.add(classToAdd);
                }
                // Or simpler if replace is available and appropriate:
                // if (elem.classList.contains(classToRemove)) {
                //    elem.classList.replace(classToRemove, classToAdd);
                // } else {
                //    elem.classList.add(classToAdd);
                // }
            });
        },

        updateFont(isMincho) {
            this._applyFontClasses(isMincho);
            const preference = isMincho ? CONFIG.STORAGE_VALUE_FONT_MINCHO : CONFIG.STORAGE_VALUE_FONT_SANS;
            Storage.set(CONFIG.STORAGE_KEY_FONT_PREF, preference);
            // Logger.log(`Font preference saved: ${preference}`); // Less verbose logging
        },

        applySavedFontPreference() {
            const savedPreference = Storage.get(CONFIG.STORAGE_KEY_FONT_PREF);
            let useMincho = false; // Default assumption (e.g., Sans)

            if (savedPreference === CONFIG.STORAGE_VALUE_FONT_MINCHO) {
                useMincho = true;
            } else if (savedPreference === CONFIG.STORAGE_VALUE_FONT_SANS) {
                useMincho = false;
            } else {
                // No valid preference saved, apply default (e.g., Sans)
                // Logger.log(`No valid font preference found, applying default.`);
                useMincho = false; // Or true if Mincho is default
            }

            // Logger.log(`Applying font preference: ${useMincho ? 'Mincho' : 'Sans'}`);
            this._applyFontClasses(useMincho);

            // Update toggle state to match applied font
            DOM.withElement(CONFIG.SELECTOR_FONT_TOGGLE, toggle => {
               if (toggle.type === 'checkbox') {
                  toggle.checked = useMincho;
               }
            });
        },

        setupToggle() {
            DOM.withElement(CONFIG.SELECTOR_FONT_TOGGLE, toggle => {
                if (toggle.type !== 'checkbox') return;

                toggle.addEventListener('change', (event) => {
                    // Check target elements exist *inside the handler* in case they are dynamic
                    if (DOM.get(CONFIG.SELECTOR_JP_SENTENCE)) {
                         this.updateFont(event.target.checked);
                    } else {
                         Logger.warn("Font toggle targets not found.");
                    }
                });
            });
        }
    };

    const UIService = {
        // Expects `isJP1KMode` boolean derived from tags
        setCardModeVisibility(isJP1KMode) {
            // Use CSS class-based visibility
            DOM.setVisibility(CONFIG.SELECTOR_JP1K_MODE_CONTAINER, isJP1KMode);
            DOM.setVisibility(CONFIG.SELECTOR_TSC_MODE_CONTAINER, !isJP1KMode);
        },

        updateRevealText() {
            DOM.withElement(CONFIG.SELECTOR_HINT_LINK, hint => {
                DOM.setText(hint, "Reveal English translation");
            });
        },

        hideMarkedAudio() {
            // WARNING: Relies on specific text format "[x]..." or "[×]...".
            // Using a data-attribute like `data-audio-marked="true"` set by the
            // template is much more robust.
            const isMarked = (audioElement) => {
                return audioElement && audioElement.textContent && /^\s*[\[(][x×][)\]]/.test(audioElement.textContent);
            };

            [CONFIG.SELECTOR_VOCAB_AUDIO, CONFIG.SELECTOR_SENT_AUDIO].forEach(selector => {
                DOM.withElement(selector, audio => {
                    if (isMarked(audio)) {
                        // Use CSS class for hiding
                        DOM.addClass(audio, CONFIG.CSS_AUDIO_HIDDEN);
                        // Ensure underlying audio controls are not accessible if needed
                        const audioControl = audio.querySelector('audio');
                        if (audioControl) audioControl.removeAttribute('controls');
                    }
                });
            });
        }
    };

    const EventService = {
        setupKeyboardShortcuts() {
            document.addEventListener("keydown", event => {
                // Ignore events in inputs, textareas, or contenteditable elements
                const target = event.target;
                if (!target || target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
                    return;
                }

                const key = event.key?.toLowerCase();
                if (!key) return;

                if (key === CONFIG.KEY_TOGGLE_FURIGANA) {
                    // Check if the specific JP1K button exists and is visible for this action
                    const jp1kButton = DOM.get(CONFIG.SELECTOR_JP1K_TOGGLE_BUTTON);
                    if (jp1kButton && !jp1kButton.classList.contains(CONFIG.CSS_HIDDEN)) {
                         FuriganaService.toggleJP1KVisibility();
                         event.preventDefault();
                    }
                    // Add other furigana toggles here if needed
                } else if (key === CONFIG.KEY_REVEAL_HINTS) {
                    // Click all *visible* matching hints on the back card
                     if (Env.isBackCard()){ // Only reveal on back card
                        DOM.withElements(CONFIG.SELECTOR_HINT_LINK, hint => {
                            // Check if hint itself is visible before clicking
                            if (!hint.offsetParent === null) { // Basic visibility check
                                hint.click();
                            }
                        });
                        event.preventDefault();
                     }
                }
            }, false); // Use bubble phase (default) unless capture is specifically needed.
        },

        setupJP1KToggleButton() {
            DOM.withElement(CONFIG.SELECTOR_JP1K_TOGGLE_BUTTON, button => {
                button.addEventListener('click', (event) => {
                    FuriganaService.toggleJP1KVisibility();
                    event.preventDefault(); // Prevent potential default button actions
                });
            });
        }
    };

    const CardInitService = {
        initializeFrontCard(isJP1KMode) {
            // Logger.log("Initializing front card features...");
            EventService.setupKeyboardShortcuts(); // Global shortcuts active on front
            if (isJP1KMode) {
                EventService.setupJP1KToggleButton(); // Only if button relevant
            }
             UIService.setCardModeVisibility(isJP1KMode); // Set visibility based on tag state
        },

        initializeBackCard() {
            // Logger.log("Initializing back card features...");
            // Pitch processing depends on hidden field existence
            if (Env.hasField(CONFIG.SELECTOR_HIDDEN_PITCH_NUM)) {
                PitchService.mark();
                PitchService.cleanDisplay();
            }
            UIService.updateRevealText();
            UIService.hideMarkedAudio();
        },

        initializeShared() {
            // Logger.log("Initializing shared features...");
            // Order matters: Process Tags first -> Apply Font -> Process Readings
            TagService.process(); // Reads DOM for tags
            FontService.applySavedFontPreference(); // Reads storage, applies classes
            FontService.setupToggle(); // Adds listener for font toggle
            FuriganaService.processMultipleReadings(); // Modifies ruby elements
        },

        initialize() {
            console.time(CONFIG.LOG_PREFIX + " Initialization"); // Start timing
            // Logger.log("Initializing Anki Japanese card script (v25.04+ Rev C)...");

            try {
                // Initialize shared features first
                this.initializeShared();

                // Determine card type and mode *after* shared init (esp. TagService)
                const isFront = Env.isFrontCard();
                const isBack = Env.isBackCard();
                const isJP1KMode = TagService.has(CONFIG.JP1K_TAG); // Get state from TagService

                // Initialize card-specific features
                if (isFront) {
                    this.initializeFrontCard(isJP1KMode);
                } else if (isBack) {
                    this.initializeBackCard();
                } else {
                    Logger.warn("Card type (Front/Back) could not be determined based on selectors.");
                }

            } catch (error) {
                Logger.error(CONFIG.ERROR_INITIALIZATION, error); // Log the full error object
                // Potentially display a user-facing error message on the card itself
            } finally {
                 console.timeEnd(CONFIG.LOG_PREFIX + " Initialization"); // End timing
                 // Logger.log("Initialization attempt finished.");
            }
        }
    };

    // --- Initialization Trigger ---
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => CardInitService.initialize());
    } else {
        // DOM is already interactive or complete
        CardInitService.initialize();
    }

})();
</script>

</script>
>>>>>>> a841e98 (overhaul)
