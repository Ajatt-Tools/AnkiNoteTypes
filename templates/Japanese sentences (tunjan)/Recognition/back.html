<div class="wrap">
  <header>
    {{#Focus}}
    <div class="tags">{{Focus}}</div>
    {{/Focus}}

    {{#Tags}}
    <div class="tags-container">
      <div class="tags">{{Tags}}</div>
    </div>
    {{/Tags}}

    <div class="jpsentence toggle-container">
      <label class="toggle-switch" title="Toggle font style (Mincho/Sans)">
        <input type="checkbox" id="fontToggle">
        <span class="slider"></span
      </label>
    </div>
  </header>

      
    <div class="sent-center">
      <div class="jpsentence" lang="ja">
        {{furigana:SentFurigana}}{{^SentFurigana}}{{furigana:SentKanji}}{{/SentFurigana}}
      </div>
      {{#SentEng}}
      <div class="ensentence" id="english-sentence" lang="en">{{hint:SentEng}}</div>
      {{/SentEng}}
    </div>



<section class="headword_section">

    {{#VocabKanji}}
      <div class="item vocab">
        <div class="audio" aria-label="Audio controls">
          <span id="vocab-audio">{{VocabAudio}}</span>
          <span id="sent-audio">{{SentAudio}}{{^SentAudio}}{{tts ja_JP voices=Apple_Kyoko:SentKanji}}{{/SentAudio}}</span>
        </div>
        <div class="reading jpsentence" id="pitchpattern" lang="ja">
          {{VocabPitchPattern}}{{^VocabPitchPattern}}{{text:kana:VocabFurigana}}{{/VocabPitchPattern}}
        </div>
        {{#VocabPitchNum}}<span class="tags" id="pitchnum">{{text:VocabPitchNum}}</span>{{/VocabPitchNum}}
        <div class="target_word jpsentence" lang="ja">{{text:kanji:VocabKanji}}</div>
    </div>
    {{/VocabKanji}}
	

    {{#VocabDef}}
    <div class="item">
        <h3>Definition</h3>
        <div class="definitions">{{edit:furigana:VocabDef}}</div>
    </div>
    {{/VocabDef}}


  {{#Notes}}
  <div class="item">
    <h3>Notes</h3>
    <div class="notes-content">{{furigana:Notes}}</div>
  </div>
  {{/Notes}}

</section>

  <footer>
    {{#SentKanji}}
    <a href="https://simplytranslate.org/?engine=google&text={{text:kanji:SentKanji}}&sl=ja&tl=en" title="Translate with SimplyTranslate" class="footer-link">Translate</a>
    <a href="https://jisho.org/search?keyword={{text:kanji:SentKanji}}" title="Sentence on Jisho" class="footer-link">Jisho</a>
    <a href="https://www.google.co.jp/search?q={{text:kanji:SentKanji}}&tbm=isch" title="Search images" class="footer-link">Images</a>
    {{/SentKanji}}
    {{#VocabKanji}}
    <a href="http://www.weblio.jp/content/{{text:VocabKanji}}" title="Vocab on Weblio" class="footer-link">Weblio</a>
    <a href="https://wadoku.de/search/?q={{text:VocabKanji}}" title="Vocab on Wadoku" class="footer-link">Wadoku</a>
    {{/VocabKanji}}
  </footer>

    
</div>

<div style="display: none">
    <div id="vocab_kanji_hidden">{{VocabKanji}}</div>
    <div id="pitchnum_hidden">{{VocabPitchNum}}</div>
    <div id="kanaword_hidden">{{kana:VocabFurigana}}</div>
</div>


<script>
/**
 * Anki Japanese Card Script (v25.04+ Rev C - Scrutinized & Refactored)
 *
 * NOTE: This script assumes specific HTML structure and CSS classes are present
 * in the Anki card template. Changes to the template may break this script.
 * Testability is limited due to direct DOM manipulation.
 * Certain checks (e.g., for hidden audio, pitch data presence) rely on potentially
 * brittle string matching or specific content formats generated by the template.
 * Using dedicated CSS classes or data-* attributes set by the template
 * for state (e.g., `data-audio-marked`, `data-pitch-present="false"`) is strongly recommended
 * for robustness but requires template modification.
 */
(function() {
    'use strict';

    // --- Configuration ---
    // Flattened structure, UPPER_SNAKE_CASE for constants.
    const CONFIG = {
        // Pitch Accent
        PITCH_CLASSES: ['pitch-heiban', 'pitch-atamadaka', 'pitch-odaka', 'pitch-nakadaka'],

        // Tags
        TAGS_TO_EXCLUDE: ["tolearn", "marked"],
        JP1K_TAG: "jp1k",

        // Furigana / Tooltips
        MAX_INLINE_READINGS: 1,

        // Keyboard Shortcuts (Front Card Only)
        KEY_TOGGLE_FURIGANA: 'p',
        KEY_REVEAL_HINTS: 'a',

        // Local Storage Keys
        STORAGE_KEY_FONT_PREF: 'ankiJpFontPreference',
        STORAGE_VALUE_FONT_MINCHO: 'mincho',
        STORAGE_VALUE_FONT_SANS: 'sans',

        // CSS Classes (Ensure these exist in your CSS)
        CSS_FONT_MINCHO: 'font-mincho',
        CSS_FONT_SANS: 'font-sans',
        CSS_HIDDEN: 'hidden', // General purpose hidden class (e.g., display: none !important;)
        CSS_VISIBLE: 'visible', // General purpose visible class (e.g., display: block/inline...;)
        CSS_TOOLTIP: 'tooltip',
        CSS_TOOLTIP_TEXT: 'tooltip-text',
        CSS_TOOLTIP_READING: 'tooltip-reading',
        CSS_FURIGANA_RT_VISIBLE: 'furigana-rt-visible', // For toggling JP1K furigana visibility
        CSS_AUDIO_HIDDEN: 'audio-hidden', // Class to hide marked audio elements
        CSS_TAG_ELEMENT: 'tags', // Class for individual tag divs

        // Selectors
        // Avoid overly complex nested selectors where possible.
        SELECTOR_TARGET_WORD: ".jpsentence b, .jpsentence strong",
        SELECTOR_FRONT_CARD_CONTAINER: ".tsc, .jp1k-mode", // Generic front card check
        SELECTOR_JP1K_MODE_CONTAINER: ".jp1k-mode",
        SELECTOR_TSC_MODE_CONTAINER: ".tsc",
        SELECTOR_JP1K_TOGGLE_BUTTON: ".jp1k-mode .toggle_furigana_button",
        SELECTOR_JP1K_RUBY_RT: ".jp1k-mode ruby rt", // JP1K specific rt for toggling

        SELECTOR_BACK_CARD_CONTAINER: ".definitions, .notes-content, #pitchnum", // Generic back card check
        SELECTOR_VOCAB_AUDIO: "#vocab-audio",
        SELECTOR_SENT_AUDIO: "#sent-audio",
        SELECTOR_HINT_LINK: "div.ensentence > a.hint",
        SELECTOR_PITCH_NUM_DISPLAY: "#pitchnum",
        SELECTOR_PITCH_PATTERN_DISPLAY: "#pitchpattern",

        SELECTOR_TAGS_CONTAINER: "header .tags-container",
        SELECTOR_FOCUS_TAG: "header > .tags:not(.tags-container .tags)", // Focus tag (outside container)
        SELECTOR_ALL_TAGS_IN_CONTAINER: "header .tags-container .tags", // Tags inside container
        SELECTOR_FONT_TOGGLE: '#fontToggle',
        SELECTOR_JP_SENTENCE: '.jpsentence',
        SELECTOR_RUBY_TOP_LEVEL: "ruby:not(ruby ruby)",

        SELECTOR_HIDDEN_PITCH_NUM: "#pitchnum_hidden",
        SELECTOR_HIDDEN_KANA_WORD: "#kanaword_hidden",
        SELECTOR_HIDDEN_VOCAB_KANJI: "#vocab_kanji_hidden",

        SELECTOR_PITCH_PATTERN_NUMBER_TAG: ".ajt__pitch_number_tag", // Within pitch pattern SVG/HTML

        // Logging & Errors
        LOG_PREFIX: "AnkiJP:",
        ERROR_LOCAL_STORAGE_READ: "Failed to read from localStorage.",
        ERROR_LOCAL_STORAGE_WRITE: "Failed to write to localStorage.",
        ERROR_CALLBACK: "Error executing callback for selector",
        ERROR_DOM_ACCESS: "DOM element not found or inaccessible for selector",
        ERROR_PITCH_CALC: "Error calculating pitch accent.",
        ERROR_RUBY_PROCESSING: "Error processing ruby element.",
        ERROR_INITIALIZATION: "Critical error during card initialization."
    };

    // --- Core Utility Services ---

    const Logger = {
        log(...args) { console.log(CONFIG.LOG_PREFIX, ...args); },
        warn(...args) { console.warn(CONFIG.LOG_PREFIX, ...args); },
        error(...args) { console.error(CONFIG.LOG_PREFIX, ...args); }
        // Note: Production logging might need levels, redirection etc.
    };

    const Storage = {
        get(key, defaultValue = null) {
            try {
                const value = localStorage.getItem(key);
                return value !== null && value !== undefined ? value : defaultValue;
            } catch (e) {
                Logger.warn(CONFIG.ERROR_LOCAL_STORAGE_READ, key, e); // Log full error
                return defaultValue;
            }
        },
        set(key, value) {
            try {
                localStorage.setItem(key, value);
                return true;
            } catch (e) {
                Logger.warn(CONFIG.ERROR_LOCAL_STORAGE_WRITE, key, e); // Log full error
                return false;
                // Consider if critical storage failures should throw
                // throw new Error(`${CONFIG.ERROR_LOCAL_STORAGE_WRITE} Key: ${key}`);
            }
        }
    };

    const DOM = {
        // Note: These assume selectors in CONFIG are valid CSS selectors.
        // Invalid selectors will throw errors upstream.
        get(selector) { return document.querySelector(selector); },
        getAll(selector) { return document.querySelectorAll(selector); },

        getText(selector) {
            const element = this.get(selector);
            return element ? element.textContent.trim() : '';
        },
        setText(element, text) {
            if (element) { element.textContent = text; }
        },
        create(tagName, options = {}) {
            const element = document.createElement(tagName);
            if (options.className) element.className = options.className;
            if (options.textContent) this.setText(element, options.textContent);
            if (options.attributes) {
                Object.entries(options.attributes).forEach(([key, value]) => {
                    element.setAttribute(key, value);
                });
            }
            return element;
        },
        addClass(element, className) {
            if (element) element.classList.add(className);
        },
        removeClass(element, className) {
            if (element) element.classList.remove(className);
        },
        toggleClass(element, className, force) {
            if (element) element.classList.toggle(className, force);
        },
        setAttributes(element, attributes) {
             if (element && attributes) {
                 Object.entries(attributes).forEach(([key, value]) => {
                     element.setAttribute(key, value);
                 });
             }
        },
        // Executes callback if element exists, re-throws callback errors.
        withElement(selector, callback) {
            const element = this.get(selector);
            if (element && typeof callback === 'function') {
                try {
                    callback(element);
                } catch (e) {
                    Logger.error(CONFIG.ERROR_CALLBACK, selector, e);
                    throw e; // Re-throw to signal failure upwards
                }
            }
            return element;
        },
        // Executes callback for each element, logs errors but continues, re-throws first error after loop.
        withElements(selector, callback) {
            const elements = this.getAll(selector);
            let firstError = null;
            if (elements.length > 0 && typeof callback === 'function') {
                elements.forEach(element => {
                    try {
                        callback(element);
                    } catch (e) {
                        Logger.error(CONFIG.ERROR_CALLBACK, selector, "(within loop)", e);
                        if (!firstError) firstError = e; // Capture first error
                    }
                });
            }
            if (firstError) throw firstError; // Re-throw the first encountered error
            return elements;
        },
        // Uses CSS classes for visibility (requires CONFIG.CSS_HIDDEN / CSS_VISIBLE in CSS)
        setVisibility(selector, isVisible) {
            this.withElements(selector, element => {
                 this.toggleClass(element, CONFIG.CSS_HIDDEN, !isVisible);
                 // Optionally add a 'visible' class if needed for specific styling overrides
                 // this.toggleClass(element, CONFIG.CSS_VISIBLE, isVisible);
            });
        },
        clearChildren(element) {
            if (element) { element.replaceChildren(); }
        },
        removeElement(element) {
             if (element && element.parentNode) {
                 element.parentNode.removeChild(element);
             }
        }
    };

    const Env = {
        // Evaluate dynamically, avoid potentially stale cache.
        isMobile() { return document.documentElement.classList.contains("mobile"); },
        isFrontCard() { return !!DOM.get(CONFIG.SELECTOR_FRONT_CARD_CONTAINER); },
        isBackCard() { return !!DOM.get(CONFIG.SELECTOR_BACK_CARD_CONTAINER); },
        // Checks if field exists AND has non-empty trimmed content
        hasField(selector) {
            const element = DOM.get(selector);
            // Ensure element exists and its textContent is not just whitespace
            return !!element && element.textContent.trim() !== '';
        }
    };

    // --- Feature-Specific Services ---

    const TagService = {
        _cachedTags: null,

        getAll() {
            if (this._cachedTags !== null) return this._cachedTags;

            const focusTagText = DOM.getText(CONFIG.SELECTOR_FOCUS_TAG);
            const containerTagsText = DOM.getText(CONFIG.SELECTOR_ALL_TAGS_IN_CONTAINER); // Corrected selector usage
            const combinedTags = `${focusTagText} ${containerTagsText}`.trim();

            this._cachedTags = combinedTags
                .split(/\s+/) // Split on whitespace
                .map(tag => tag.trim().toLowerCase())
                .filter(Boolean); // Remove empty strings

            return this._cachedTags;
        },

        has(tagName) {
            return this.getAll().includes(tagName.toLowerCase());
        },

        process() {
            // Dependency: Called before UI changes based on tags (e.g., JP1K mode)
            const tagsContainer = DOM.get(CONFIG.SELECTOR_TAGS_CONTAINER);
            if (!tagsContainer) return;

            const allTags = this.getAll();

            // Remove original focus tag element if it exists and is separate
            DOM.withElement(CONFIG.SELECTOR_FOCUS_TAG, DOM.removeElement);
            // Clear existing tags *within* the container if they were structured differently before
            DOM.withElements(CONFIG.SELECTOR_ALL_TAGS_IN_CONTAINER, DOM.removeElement);
            // Or simply clear the whole container if it only holds tags:
            // DOM.clearChildren(tagsContainer);


            let tagsAdded = false;
            const fragment = document.createDocumentFragment();

            allTags.forEach(tag => {
                if (!CONFIG.TAGS_TO_EXCLUDE.includes(tag)) {
                    const tagElem = DOM.create('div', {
                        className: CONFIG.CSS_TAG_ELEMENT, // Use class name constant
                        textContent: tag
                    });
                    fragment.appendChild(tagElem);
                    tagsAdded = true;
                }
            });

            if (tagsAdded) {
                tagsContainer.appendChild(fragment);
                DOM.removeClass(tagsContainer, CONFIG.CSS_HIDDEN); // Make visible using class
            } else {
                DOM.addClass(tagsContainer, CONFIG.CSS_HIDDEN); // Hide using class
            }
        }
    };

    const PitchService = {
        // Use fixed cache property names
        _pitchNumElementCache: null,
        _kanaWordElementCache: null,
        _vocabKanjiElementCache: null,

        _getHiddenElement(selectorKey) { // Pass key string e.g., 'pitchNum'
            const cacheProp = `_${selectorKey}ElementCache`;
            const selector = CONFIG[`SELECTOR_HIDDEN_${selectorKey.toUpperCase()}`];
            if (!this[cacheProp]) {
                 this[cacheProp] = DOM.get(selector);
            }
            return this[cacheProp];
        },
        _getHiddenText(selectorKey) {
            const element = this._getHiddenElement(selectorKey);
            return element ? element.textContent.trim() : '';
        },

        getAccentNumber() {
            const pitchText = this._getHiddenText('pitchNum');
            if (!pitchText) return null;
            // Use parseInt for number extraction, handle non-numeric results
            const pitchNum = parseInt(pitchText.replace(/[\[\]]/g, ""), 10); // Remove brackets first
            return isNaN(pitchNum) ? null : pitchNum;
        },

        _calculateMoras(text) {
            if (!text) return 0;
            // WARNING: This mora calculation is basic and may fail on edge cases.
            // Consider a dedicated library for robust Japanese text processing if accuracy is critical.
            const morasText = text.replace(/[（(＜].*[＞)）]/, ""); // Remove simple parentheticals
            return morasText.replace(/[ャュョゃゅょァィゥェォ]/g, "").length; // Remove small kana/lengthening
        },

        // Refactored slightly for clarity
        _isOdaka(pitchNum, kanaText, vocabKanji) {
            // Guard clauses
            if (pitchNum === null || pitchNum <= 0 || !kanaText) return false;

            try {
                const morasCount = this._calculateMoras(kanaText);
                if (morasCount === 0) return false; // Cannot be odaka if no moras

                // Adjust count for な-adjectives ending in な
                const isNaAdjEndingNa = /な$/.test(vocabKanji) && kanaText.endsWith('な');
                const adjustedCount = isNaAdjEndingNa ? morasCount - 1 : morasCount;

                // Ensure adjusted count is positive before comparison
                return adjustedCount > 0 && adjustedCount === pitchNum;

            } catch (e) {
                Logger.error(CONFIG.ERROR_PITCH_CALC, "(isOdaka)", e);
                return false;
            }
        },

        getAccentClass(pitchNum) {
            if (pitchNum === null) return null;
            if (pitchNum === 0) return CONFIG.PITCH_CLASSES[0]; // Heiban
            if (pitchNum === 1) return CONFIG.PITCH_CLASSES[1]; // Atamadaka

            if (pitchNum > 1) {
                // Fetch dependencies needed for odaka check
                const kanaWord = this._getHiddenText('kanaWord');
                const vocabKanji = this._getHiddenText('vocabKanji');
                return this._isOdaka(pitchNum, kanaWord, vocabKanji)
                       ? CONFIG.PITCH_CLASSES[2] // Odaka
                       : CONFIG.PITCH_CLASSES[3]; // Nakadaka
            }
            return null; // Should not be reached
        },

        styleTargetWord(className) {
            DOM.withElements(CONFIG.SELECTOR_TARGET_WORD, word => {
                // More targeted class manipulation
                let classRemoved = false;
                CONFIG.PITCH_CLASSES.forEach(cls => {
                    if (word.classList.contains(cls)) {
                        DOM.removeClass(word, cls);
                        classRemoved = true;
                    }
                });
                // Add the new class if provided
                if (className) {
                    DOM.addClass(word, className);
                }
                // Alternatively, using classList.replace (might be simpler if always replacing)
                // const currentClass = CONFIG.PITCH_CLASSES.find(cls => word.classList.contains(cls));
                // if (currentClass && className && currentClass !== className) {
                //     word.classList.replace(currentClass, className);
                // } else if (currentClass && !className) {
                //     DOM.removeClass(word, currentClass);
                // } else if (!currentClass && className) {
                //     DOM.addClass(word, className);
                // }
            });
        },

        mark() {
            const pitchNum = this.getAccentNumber();
            const accentClass = this.getAccentClass(pitchNum); // Handles null pitchNum
            this.styleTargetWord(accentClass); // Handles null accentClass
        },

        cleanDisplay() {
            // Remove brackets from pitch number display
            DOM.withElement(CONFIG.SELECTOR_PITCH_NUM_DISPLAY, elem => {
                DOM.setText(elem, elem.textContent.replace(/[\[\]]/g, ""));
            });

            // WARNING: The following relies on specific text "no pitch accent".
            // Using data attributes or classes set by the template is more robust.
            const hasNoDataText = (el) => el && el.textContent.toLowerCase().includes("no pitch accent");

            const pitchNumElem = DOM.get(CONFIG.SELECTOR_PITCH_NUM_DISPLAY);
            if (hasNoDataText(pitchNumElem)) DOM.removeElement(pitchNumElem);

            DOM.withElement(CONFIG.SELECTOR_PITCH_PATTERN_DISPLAY, pitchPatternElem => {
                 const pitchNumSpan = pitchPatternElem.querySelector(CONFIG.SELECTOR_PITCH_PATTERN_NUMBER_TAG);
                 if (hasNoDataText(pitchNumSpan)) DOM.removeElement(pitchNumSpan);

                 if (hasNoDataText(pitchPatternElem)) {
                     const kanaWord = this._getHiddenText('kanaWord');
                     if (kanaWord) {
                          DOM.setText(pitchPatternElem, kanaWord);
                     } else {
                          DOM.removeElement(pitchPatternElem);
                     }
                 }
            });
        }
    };

    const FuriganaService = {
        _createRubyContent(kanji, readings) {
            const fragment = document.createDocumentFragment();
            fragment.appendChild(DOM.create('rb', { textContent: kanji }));
            readings.forEach(reading => {
                fragment.appendChild(DOM.create('rt', { textContent: reading }));
            });
            return fragment;
        },
        _createTooltip(kanji, allReadings) {
            const inlineReadings = allReadings.slice(0, CONFIG.MAX_INLINE_READINGS);
            const tooltipReadings = allReadings.slice(CONFIG.MAX_INLINE_READINGS);

            const inlineRuby = DOM.create('ruby');
            inlineRuby.appendChild(this._createRubyContent(kanji, inlineReadings));

            const tooltipText = DOM.create('span', { className: CONFIG.CSS_TOOLTIP_TEXT });
            tooltipReadings.forEach(reading => {
                tooltipText.appendChild(DOM.create('span', {
                    className: CONFIG.CSS_TOOLTIP_READING,
                    textContent: reading
                }));
            });

            const tooltip = DOM.create('span', { className: CONFIG.CSS_TOOLTIP });
            tooltip.appendChild(inlineRuby);
            tooltip.appendChild(tooltipText);
            return tooltip;
        },

        processMultipleReadings() {
            DOM.withElements(CONFIG.SELECTOR_RUBY_TOP_LEVEL, ruby => {
                // Inner try...catch for resilience against single element failure
                try {
                    const rbElement = ruby.querySelector("rb");
                    const rtElement = ruby.querySelector("rt");
                    if (!rbElement || !rtElement || !rtElement.textContent) return;

                    const kanji = rbElement.textContent.trim();
                    const readingsRaw = rtElement.textContent.trim();
                    if (!kanji || !readingsRaw) return;

                    // Robust splitting (adjust regex if format differs)
                    const readings = readingsRaw
                        .split(/[\s;,.、・。]+/u) // Split on various separators
                        .map(str => str.trim())
                        .filter(Boolean); // Remove empty strings

                    if (readings.length > CONFIG.MAX_INLINE_READINGS) {
                        const tooltipElement = this._createTooltip(kanji, readings);
                        ruby.replaceWith(tooltipElement);
                    } else if (readings.length > 0 && readings.length <= CONFIG.MAX_INLINE_READINGS) {
                        // Ensure correct structure even if <= MAX_INLINE_READINGS
                        // Rebuild safely if necessary (e.g., original rt had multiple spaced readings)
                        const simpleRuby = DOM.create('ruby');
                        simpleRuby.appendChild(this._createRubyContent(kanji, readings));
                        ruby.replaceWith(simpleRuby);
                    }
                    // Else: 0 readings found after split/filter, leave original structure? Or remove rt?
                    // Current logic leaves original structure if readings array is empty.

                } catch (error) {
                    Logger.error(CONFIG.ERROR_RUBY_PROCESSING, error, ruby);
                    // Continue with the next ruby element
                }
            });
        },

        // Toggle visibility using CSS class
        toggleJP1KVisibility() {
            // Only affects specific rt elements in JP1K mode
            DOM.withElements(CONFIG.SELECTOR_JP1K_RUBY_RT, rt => {
                // Check current visibility based on class presence *or* computed style if needed
                // For simplicity, assume class toggling is sufficient
                DOM.toggleClass(rt, CONFIG.CSS_FURIGANA_RT_VISIBLE);
            });
        }
    };

    const FontService = {
        _applyFontClasses(isMincho) {
            const classToAdd = isMincho ? CONFIG.CSS_FONT_MINCHO : CONFIG.CSS_FONT_SANS;
            const classToRemove = isMincho ? CONFIG.CSS_FONT_SANS : CONFIG.CSS_FONT_MINCHO;

            // Apply to all relevant elements efficiently
            DOM.withElements(CONFIG.SELECTOR_JP_SENTENCE, elem => {
                // Use classList methods for efficiency
                if (elem.classList.contains(classToRemove)) {
                    elem.classList.remove(classToRemove);
                }
                if (!elem.classList.contains(classToAdd)) {
                    elem.classList.add(classToAdd);
                }
                // Or simpler if replace is available and appropriate:
                // if (elem.classList.contains(classToRemove)) {
                //    elem.classList.replace(classToRemove, classToAdd);
                // } else {
                //    elem.classList.add(classToAdd);
                // }
            });
        },

        updateFont(isMincho) {
            this._applyFontClasses(isMincho);
            const preference = isMincho ? CONFIG.STORAGE_VALUE_FONT_MINCHO : CONFIG.STORAGE_VALUE_FONT_SANS;
            Storage.set(CONFIG.STORAGE_KEY_FONT_PREF, preference);
            // Logger.log(`Font preference saved: ${preference}`); // Less verbose logging
        },

        applySavedFontPreference() {
            const savedPreference = Storage.get(CONFIG.STORAGE_KEY_FONT_PREF);
            let useMincho = false; // Default assumption (e.g., Sans)

            if (savedPreference === CONFIG.STORAGE_VALUE_FONT_MINCHO) {
                useMincho = true;
            } else if (savedPreference === CONFIG.STORAGE_VALUE_FONT_SANS) {
                useMincho = false;
            } else {
                // No valid preference saved, apply default (e.g., Sans)
                // Logger.log(`No valid font preference found, applying default.`);
                useMincho = false; // Or true if Mincho is default
            }

            // Logger.log(`Applying font preference: ${useMincho ? 'Mincho' : 'Sans'}`);
            this._applyFontClasses(useMincho);

            // Update toggle state to match applied font
            DOM.withElement(CONFIG.SELECTOR_FONT_TOGGLE, toggle => {
               if (toggle.type === 'checkbox') {
                  toggle.checked = useMincho;
               }
            });
        },

        setupToggle() {
            DOM.withElement(CONFIG.SELECTOR_FONT_TOGGLE, toggle => {
                if (toggle.type !== 'checkbox') return;

                toggle.addEventListener('change', (event) => {
                    // Check target elements exist *inside the handler* in case they are dynamic
                    if (DOM.get(CONFIG.SELECTOR_JP_SENTENCE)) {
                         this.updateFont(event.target.checked);
                    } else {
                         Logger.warn("Font toggle targets not found.");
                    }
                });
            });
        }
    };

    const UIService = {
        // Expects `isJP1KMode` boolean derived from tags
        setCardModeVisibility(isJP1KMode) {
            // Use CSS class-based visibility
            DOM.setVisibility(CONFIG.SELECTOR_JP1K_MODE_CONTAINER, isJP1KMode);
            DOM.setVisibility(CONFIG.SELECTOR_TSC_MODE_CONTAINER, !isJP1KMode);
        },

        updateRevealText() {
            DOM.withElement(CONFIG.SELECTOR_HINT_LINK, hint => {
                DOM.setText(hint, "Reveal English translation");
            });
        },

        hideMarkedAudio() {
            // WARNING: Relies on specific text format "[x]..." or "[×]...".
            // Using a data-attribute like `data-audio-marked="true"` set by the
            // template is much more robust.
            const isMarked = (audioElement) => {
                return audioElement && audioElement.textContent && /^\s*[\[(][x×][)\]]/.test(audioElement.textContent);
            };

            [CONFIG.SELECTOR_VOCAB_AUDIO, CONFIG.SELECTOR_SENT_AUDIO].forEach(selector => {
                DOM.withElement(selector, audio => {
                    if (isMarked(audio)) {
                        // Use CSS class for hiding
                        DOM.addClass(audio, CONFIG.CSS_AUDIO_HIDDEN);
                        // Ensure underlying audio controls are not accessible if needed
                        const audioControl = audio.querySelector('audio');
                        if (audioControl) audioControl.removeAttribute('controls');
                    }
                });
            });
        }
    };

    const EventService = {
        setupKeyboardShortcuts() {
            document.addEventListener("keydown", event => {
                // Ignore events in inputs, textareas, or contenteditable elements
                const target = event.target;
                if (!target || target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
                    return;
                }

                const key = event.key?.toLowerCase();
                if (!key) return;

                if (key === CONFIG.KEY_TOGGLE_FURIGANA) {
                    // Check if the specific JP1K button exists and is visible for this action
                    const jp1kButton = DOM.get(CONFIG.SELECTOR_JP1K_TOGGLE_BUTTON);
                    if (jp1kButton && !jp1kButton.classList.contains(CONFIG.CSS_HIDDEN)) {
                         FuriganaService.toggleJP1KVisibility();
                         event.preventDefault();
                    }
                    // Add other furigana toggles here if needed
                } else if (key === CONFIG.KEY_REVEAL_HINTS) {
                    // Click all *visible* matching hints on the back card
                     if (Env.isBackCard()){ // Only reveal on back card
                        DOM.withElements(CONFIG.SELECTOR_HINT_LINK, hint => {
                            // Check if hint itself is visible before clicking
                            if (!hint.offsetParent === null) { // Basic visibility check
                                hint.click();
                            }
                        });
                        event.preventDefault();
                     }
                }
            }, false); // Use bubble phase (default) unless capture is specifically needed.
        },

        setupJP1KToggleButton() {
            DOM.withElement(CONFIG.SELECTOR_JP1K_TOGGLE_BUTTON, button => {
                button.addEventListener('click', (event) => {
                    FuriganaService.toggleJP1KVisibility();
                    event.preventDefault(); // Prevent potential default button actions
                });
            });
        }
    };

    const CardInitService = {
        initializeFrontCard(isJP1KMode) {
            // Logger.log("Initializing front card features...");
            EventService.setupKeyboardShortcuts(); // Global shortcuts active on front
            if (isJP1KMode) {
                EventService.setupJP1KToggleButton(); // Only if button relevant
            }
             UIService.setCardModeVisibility(isJP1KMode); // Set visibility based on tag state
        },

        initializeBackCard() {
            // Logger.log("Initializing back card features...");
            // Pitch processing depends on hidden field existence
            if (Env.hasField(CONFIG.SELECTOR_HIDDEN_PITCH_NUM)) {
                PitchService.mark();
                PitchService.cleanDisplay();
            }
            UIService.updateRevealText();
            UIService.hideMarkedAudio();
        },

        initializeShared() {
            // Logger.log("Initializing shared features...");
            // Order matters: Process Tags first -> Apply Font -> Process Readings
            TagService.process(); // Reads DOM for tags
            FontService.applySavedFontPreference(); // Reads storage, applies classes
            FontService.setupToggle(); // Adds listener for font toggle
            FuriganaService.processMultipleReadings(); // Modifies ruby elements
        },

        initialize() {
            console.time(CONFIG.LOG_PREFIX + " Initialization"); // Start timing
            // Logger.log("Initializing Anki Japanese card script (v25.04+ Rev C)...");

            try {
                // Initialize shared features first
                this.initializeShared();

                // Determine card type and mode *after* shared init (esp. TagService)
                const isFront = Env.isFrontCard();
                const isBack = Env.isBackCard();
                const isJP1KMode = TagService.has(CONFIG.JP1K_TAG); // Get state from TagService

                // Initialize card-specific features
                if (isFront) {
                    this.initializeFrontCard(isJP1KMode);
                } else if (isBack) {
                    this.initializeBackCard();
                } else {
                    Logger.warn("Card type (Front/Back) could not be determined based on selectors.");
                }

            } catch (error) {
                Logger.error(CONFIG.ERROR_INITIALIZATION, error); // Log the full error object
                // Potentially display a user-facing error message on the card itself
            } finally {
                 console.timeEnd(CONFIG.LOG_PREFIX + " Initialization"); // End timing
                 // Logger.log("Initialization attempt finished.");
            }
        }
    };

    // --- Initialization Trigger ---
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => CardInitService.initialize());
    } else {
        // DOM is already interactive or complete
        CardInitService.initialize();
    }

})();
</script>

</script>
